.TH std::lerp 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::lerp \- std::lerp

.SH Synopsis
   Defined in header <cmath>
   constexpr float       lerp( float a, float b, float t ) noexcept;  \fB(1)\fP \fI(since C++20)\fP
   constexpr double      lerp( double a, double b, double t )         \fB(2)\fP \fI(since C++20)\fP
   noexcept;
   constexpr long double lerp( long double a, long double b, long     \fB(3)\fP \fI(since C++20)\fP
   double t ) noexcept;
   constexpr Promoted    lerp( Arithmetic1 a, Arithmetic2 b,          \fB(4)\fP \fI(since C++20)\fP
   Arithmetic3 t ) noexcept;

   1-3) Computes \\(a+t(b−a)\\)a+t(b−a), i.e. the linear interpolation between a and b
   for the parameter t (or extrapolation, when t is outside the range [0,1]).
   4) A set of overloads or a function template for all combinations of arguments of
   arithmetic type not covered by 1-3). If any argument has integral type, it is cast
   to double. If any other argument is long double, then the return type is long
   double, otherwise it is double.

.SH Parameters

   a, b, t - values of floating-point or integral types

.SH Return value

   \\(a+t(b−a)\\)a+t(b−a)

   When isfinite(a) && isfinite(b), the following properties are guaranteed:

     * If t == 0, the result is equal to a.
     * If t == 1, the result is equal to b.
     * If t >= 0 && t <= 1, the result is finite.
     * If isfinite(t) && a == b, the result is equal to a.
     * If isfinite(t) || (!isnan(t) && b-a != 0), the result is not NaN.

   Let CMP(x,y) be 1 if x > y, -1 if x < y, and 0 otherwise. For any t1 and t2, the
   product of CMP(lerp(a, b, t2), lerp(a, b, t1)), CMP(t2, t1), and CMP(b, a) is
   non-negative. (That is, lerp is monotonic.)

.SH Notes

   lerp is available in the global namespace when <math.h> is included, even if it is
   not a part of C.

.SH Example


// Run this code

 #include <iostream>
 #include <cmath>

 int main()
 {
     float a=10.0f, b=20.0f;

     std::cout << "a=" << a << ", " << "b=" << b << '\\n'
               << "mid point=" << std::lerp(a,b,0.5f) << '\\n'
               << std::boolalpha << (a == std::lerp(a,b,0.0f)) << ' '
               << std::boolalpha << (b == std::lerp(a,b,1.0f)) << '\\n';
 }

.SH Output:

 a=10, b=20
 mid point=15
 true true

.SH See also

   midpoint midpoint between two numbers or pointers
   (C++20)  \fI(function template)\fP
