.TH std::pair::operator= 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::pair::operator= \- std::pair::operator=

.SH Synopsis
   pair& operator=( const pair& other );                (until
                                                        C++20)
   constexpr pair& operator=( const pair& other         (since
   );                                                   C++20)
                                                                (since
   template< class U1, class U2 >                               C++11)
   pair& operator=( const pair<U1,U2>& other );                 (until
                                                                C++20)
   template< class U1, class U2 >                               (since
   constexpr pair& operator=( const                             C++20)
   pair<U1,U2>& other );
                                                \fB(1)\fP                     (since
   pair& operator=( pair&& other ) noexcept(/*                          C++11)
   see below */);                                   \fB(2)\fP                 (until
                                                                        C++20)
   constexpr pair& operator=( pair&& other )                            (since
   noexcept(/* see below */);                                           C++20)
                                                        \fB(3)\fP                     (since
   template< class U1, class U2 >                                               C++11)
   pair& operator=( pair<U1,U2>&& other );                                      (until
                                                                \fB(4)\fP             C++20)
   template< class U1, class U2 >                                               (since
   constexpr pair& operator=( pair<U1,U2>&&                                     C++20)
   other );

   Replaces the contents of the pair.

   1) Copy assignment operator. Replaces the contents with a copy of the contents of
   other.

     * The assignment operator is implicitly declared. Using this
       assignment operator makes the program ill-formed if either
       first_type or second_type is a const-qualified type, or a          \fI(until C++11)\fP
       reference type, or a class type with an inaccessible copy
       assignment operator, or an array type of such class.
     * This overload is defined as deleted if either
       std::is_copy_assignable<first_type>::value or                      \fI(since C++11)\fP
       std::is_copy_assignable<second_type>::value is false.

   2) Assigns other.first to first and other.second to second.

     * This overload only participates in overload resolution if
       std::is_assignable<first_type&, const U1&>::value and
       std::is_assignable<second_type&, const U2&>::value are both true.

   3) Move assignment operator. Replaces the contents with those of other using move
   semantics.

     * This overload only participates in overload resolution if
       std::is_move_assignable<first_type>::value and
       std::is_move_assignable<second_type>::value are both true.

   4) Assigns std::forward<U1>(p.first) to first and std::forward<U2>(p.second) to
   second.

     * This overload only participates in overload resolution if
       std::is_assignable<first_type&, U1>::value and std::is_assignable<second_type&,
       U2>::value are both true.

.SH Parameters

   other - pair of values to replace the contents of this pair

.SH Return value

   *this

.SH Exceptions

   1-2) May throw implementation-defined exceptions.
   3)
   noexcept specification:
   noexcept(

       std::is_nothrow_move_assignable<T1>::value &&
       std::is_nothrow_move_assignable<T2>::value

   )
   4) May throw implementation-defined exceptions.

.SH Example


// Run this code

 #include <iomanip>
 #include <iostream>
 #include <utility>
 #include <vector>

 template <class Os, class T>
 Os& operator<<(Os& os, const std::vector<T>& v) {
     os << "{";
     for (std::size_t t = 0; t != v.size(); ++t)
         os << v[t] << (t+1 < v.size() ? "," : "");
     return os << "}";
 }

 template <class Os, class U1, class U2>
 Os& operator<<(Os& os, const std::pair<U1, U2>& pair) {
     return os << ":{ " << pair.first << ", " << pair.second << " } ";
 }

 int main()
 {
     std::pair<int, std::vector<int>> p{ 1, {2} }, q{ 2, {5,6} };

     p = q; // (1) operator=( const pair& other );
     std::cout << std::setw(23) << std::left
               << "(1) p = q;" << "p" << p << "   q" << q << '\\n';

     std::pair<short, std::vector<int>> r{ 4, {7,8,9} };
     p = r; // (2) operator=( const pair<U1,U2>& other );
     std::cout << std::setw(23)
               << "(2) p = r;" << "p" << p << " r" << r << '\\n';

     p = std::pair<int, std::vector<int>>{ 3, {4} };
     p = std::move(q); // (3) operator=( pair&& other );
     std::cout << std::setw(23)
               << "(3) p = std::move(q);" << "p" << p << "   q" << q << '\\n';

     p = std::pair<int, std::vector<int>>{ 5, {6} };
     p = std::move(r); // (4) operator=( pair<U1,U2>&& other );
     std::cout << std::setw(23)
               << "(4) p = std::move(r);" << "p" << p << " r" << r << '\\n';
 }

.SH Output:

 \fB(1)\fP p = q;             p:{ 2, {5,6} }    q:{ 2, {5,6} }
 \fB(2)\fP p = r;             p:{ 4, {7,8,9} }  r:{ 4, {7,8,9} }
 \fB(3)\fP p = std::move(q);  p:{ 2, {5,6} }    q:{ 2, {} }
 \fB(4)\fP p = std::move(r);  p:{ 4, {7,8,9} }  r:{ 4, {} }

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to            Behavior as published            Correct behavior
   LWG 2729 C++11      pair::operator= was unconstrained and might constrained
                       result in unnecessary undefined behavior

.SH See also


.SH Category:

     * conditionally noexcept
