.TH std::format 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::format \- std::format

.SH Synopsis
   Defined in header <format>
   template<class... Args>                                            \fB(1)\fP \fI(since C++20)\fP
   std::string format(std::string_view fmt, const Args&... args);
   template<class... Args>                                            \fB(2)\fP \fI(since C++20)\fP
   std::wstring format(std::wstring_view fmt, const Args&... args);
   template<class... Args>
   std::string format(const std::locale& loc, std::string_view fmt,   \fB(3)\fP \fI(since C++20)\fP
   const Args&... args);
   template<class... Args>
   std::wstring format(const std::locale& loc, std::wstring_view fmt, \fB(4)\fP \fI(since C++20)\fP
   const Args&... args);

   Format args according to the format string fmt, and return the result as a string.
   If present, loc is used for locale-specific formatting.

   The behavior is undefined if std::formatter<Ti, CharT> does not meet the Formatter
   requirements for any Ti in Args, where CharT is decltype(fmt)::char_type (char for
   overloads (1,3), wchar_t for overloads (2,4)).

.SH Parameters

             string view representing the format string.

             The format string consists of

               * ordinary characters (except { and }), which are copied unchanged to
                 the output,
               * escape sequences {{ and }}, which are replaced with { and }
                 respectively in the output, and
               * replacement fields.

             Each replacement field has the following format:

               * introductory { character;
               * (optional) arg-id, a non-negative number;
               * (optional) a colon (:) followed by a format specification;
   fmt     -   * final } character.

             arg-id specifies the index of the argument in args whose value is to be
             used for formatting; if arg-id is omitted, the arguments are used in
             order. The arg-ids in a format string must all be present or all be
             omitted. Mixing manual and automatic indexing is an error.

             The format specification is defined by the std::formatter specialization
             for the corresponding argument.

               * For basic types and standard string types, the format specification is
                 interpreted as standard format specification.
               * For chrono types, the format specification is interpreted as chrono
                 format specification.
               * For other formattable types, the format specification is determined by
                 user-defined formatter specializations.
   args... - arguments to be formatted
   loc     - std::locale used for locale-specific formatting

.SH Return value

   A string object holding the formatted result.

.SH Exceptions

   Throws std::format_error if fmt is not a valid format string for the provided
   arguments. Also propagates exception thrown by any formatter.

.SH Notes

   It is not an error to provide more arguments than the format string requires:

 std::format("{} {}!", "Hello", "world", "something"); // OK, produces "Hello world!"

.SH Example


// Run this code

 #include <iostream>
 #include <format>

 int main() {
     std::cout << std::format("Hello {}!\\n", "world");
 }

.SH Output:

 Hello world!

.SH See also

   format_to   writes out formatted representation of its arguments through an output
   (C++20)     iterator
               \fI(function template)\fP
   format_to_n writes out formatted representation of its arguments through an output
   (C++20)     iterator, not exceeding specified size
               \fI(function template)\fP
