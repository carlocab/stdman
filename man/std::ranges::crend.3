.TH std::ranges::crend 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::crend \- std::ranges::crend

.SH Synopsis
   Defined in header <ranges>
   inline namespace /*unspecified*/ {
                                                                   \fI(since C++20)\fP
       inline constexpr /*unspecified*/ crend = /*unspecified*/;   (customization point
                                                                   object)
   }
   Call signature
   template< class T >

       requires /* see below */

   constexpr std::sentinel_for<ranges::iterator_t<T>> auto
   crend(T&& t);

   Returns a sentinel indicating the end of a const-qualified range that is treated as
   a reversed sequence.

   range-rbegin-rend.svg

   Let CT be

    1. const std::remove_reference_t<T>& if the argument is a lvalue (i.e. T is an
       lvalue reference type),
    2. const T otherwise,

   a call to ranges::crend is expression-equivalent to
   ranges::rend(static_cast<CT&&>(t)).

   If ranges::crend(e) is valid for an expression e, then std::sentinel_for<S, I> is
   true in all cases, where S is decltype(ranges::crend(e)), and I is
   decltype(ranges::crbegin(e)).

.SH Example


// Run this code

 #include <iostream>
 #include <vector>
 #include <iterator>
 #include <algorithm>

 int main()
 {
     int a[] = {4, 6, -3, 9, 10};
     std::cout << "Array backwards: ";
     namespace ranges = std::ranges;
     ranges::copy(ranges::rbegin(a), ranges::rend(a),
                  std::ostream_iterator<int>(std::cout, " "));

     std::cout << "\\nVector backwards: ";
     std::vector<int> v = {4, 6, -3, 9, 10};
     ranges::copy(ranges::rbegin(v), ranges::rend(v),
                  std::ostream_iterator<int>(std::cout, " "));
 }

.SH Output:

 Array backwards: 10 9 -3 6 4
 Vector backwards: 10 9 -3 6 4

.SH See also

   ranges::rend returns a reverse end iterator to a range
   (C++20)      (customization point object)
   rend         returns a reverse end iterator for a container or array
   crend        \fI(function template)\fP
   \fI(C++14)\fP
