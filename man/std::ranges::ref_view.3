.TH std::ranges::ref_view 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::ref_view \- std::ranges::ref_view

.SH Synopsis
   Defined in header <ranges>
   template<ranges::range R>

       requires std::is_object_v<R>                             \fI(since C++20)\fP

   class ref_view : public ranges::view_interface<ref_view<R>>

   ref_view is a view of the elements of some other range. It wraps a reference to that
   range.

.SH Member functions

std::ranges::ref_view::ref_view

   constexpr ref_view() noexcept = default;                                        \fB(1)\fP
   template<__NotSameAs<ref_view> T>

       requires std::convertible_to<T, R&> && requires { _FUN(std::declval<T>());  \fB(2)\fP
   }

   constexpr ref_view(T&& t);

   1) Initializes r_ with nullptr. A default-initialized ref_view references no range.
   2) Initializes r_ with std::addressof(static_cast<R&>(std::forward<T>(t))).

   Names __NotSameAs and _FUN are exposition-only. __NotSameAs<T, U> is satisfied if
   and only if !std::same_as<std::remove_cvref_t<T>, std::remove_cvref_t<U>>. The
   function _FUN are declared as void _FUN(R&); void _FUN(R&&) = delete;.

.SH Parameters

   t - range to reference

std::ranges::ref_view::base

   constexpr R& base() const;

   Equivalent to return *r_;

std::ranges::ref_view::begin

   constexpr ranges::iterator_t<R> begin() const;

   Equivalent to return ranges::begin(*r_);

std::ranges::ref_view::end

   constexpr ranges::sentinel_t<R> end() const;

   Equivalent to return ranges::end(*r_);

std::ranges::ref_view::empty

   constexpr bool empty() const
       requires requires { ranges::empty(*r_); };

   Equivalent to return ranges::empty(*r_);

std::ranges::ref_view::size

   constexpr auto size() const

       requires ranges::sized_range<R>

   { return ranges::size(*r_); }

std::ranges::ref_view::data

   constexpr auto data() const

       requires ranges::contiguous_range<R>

   { return ranges::data(*r_); }

   Deduction guides

   template<class R>
   ref_view(R&) -> ref_view<R>;

.SH Example


// Run this code

 #include <ranges>
 #include <iostream>

 int main()
 {
     const std::string s{"cosmos"};

     const std::ranges::take_view tv{s, 3};
     const std::ranges::ref_view rv{tv};

     std::cout
         << std::boolalpha
         << "call empty() : " << rv.empty() << '\\n'
         << "call size()  : " << rv.size() << '\\n'
         << "call begin() : " << *rv.begin() << '\\n'
         << "call end()   : " << *(rv.end()-1) << '\\n'
         << "call data()  : " << rv.data() << '\\n'
         << "call base()  : " << rv.base().size() << '\\n' // ~> tv.size()
         << "range-for    : ";

     for (const auto c: rv) { std::cout << c; }
     std::cout << '\\n';
 }

.SH Output:

 call empty() : false
 call size()  : 3
 call begin() : c
 call end()   : s
 call data()  : cosmos
 call base()  : 3
 range-for    : cos

.SH See also

   reference_wrapper CopyConstructible and CopyAssignable reference wrapper
   \fI(C++11)\fP           \fI(class template)\fP
   views::all_t      a view that includes all elements of a range
   views::all        (alias template) (range adaptor object)
