.TH std::reverse_iterator 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::reverse_iterator \- std::reverse_iterator

.SH Synopsis
   Defined in header <iterator>
   template< class Iter >

   class reverse_iterator : public std::iterator<
                              typename
   std::iterator_traits<Iter>::iterator_category,
                              typename
   std::iterator_traits<Iter>::value_type,                                \fI(until C++17)\fP
                              typename
   std::iterator_traits<Iter>::difference_type,
                              typename
   std::iterator_traits<Iter>::pointer,

                              typename
   std::iterator_traits<Iter>::reference >
   template< class Iter >                                                 \fI(since C++17)\fP
   class reverse_iterator;

   std::reverse_iterator is an iterator adaptor that reverses the direction of a given
   iterator. In other words, when provided with a bidirectional iterator,
   std::reverse_iterator produces a new iterator that moves from the end to the
   beginning of the sequence defined by the underlying bidirectional iterator.

   For a reverse iterator r constructed from an iterator i, the relationship &*r ==
   &*(i-1) is always true (as long as r is dereferenceable); thus a reverse iterator
   constructed from a one-past-the-end iterator dereferences to the last element in a
   sequence.

   This is the iterator returned by member functions rbegin() and rend() of the
   standard library containers.

   range-rbegin-rend.svg

.SH Member types

   Member type       Definition
   iterator_type     Iter
   iterator_concept  If Iter models std::random_access_iterator, this is
   \fI(since C++20)\fP     std::random_access_iterator_tag. Otherwise, this is
                     std::bidirectional_iterator_tag
                     std::iterator_traits<Iter>::iterator_category               (until
                                                                                 C++20)
   iterator_category If std::iterator_traits<Iter>::iterator_category models
                     std::derived_from<std::random_access_iterator_tag>, this is (since
                     std::random_access_iterator_tag. Otherwise, this is         C++20)
                     std::iterator_traits<Iter>::iterator_category unchanged
   value_type        std::iterator_traits<Iter>::value_type \fI(until C++20)\fP
                     std::iter_value_t<Iter>                \fI(since C++20)\fP
   difference_type   std::iterator_traits<Iter>::difference_type \fI(until C++20)\fP
                     std::iter_difference_t<Iter>                \fI(since C++20)\fP
   pointer           std::iterator_traits<Iter>::pointer
   reference         std::iterator_traits<Iter>::reference \fI(until C++20)\fP
                     std::iter_reference_t<Iter>           \fI(since C++20)\fP

   Member types iterator_category, value_type, difference_type, pointer and
   reference are required to be obtained by inheriting from
   std::iterator<std::iterator_traits<Iter>::iterator_category
   , std::iterator_traits<Iter>::value_type                                      (until
   , std::iterator_traits<Iter>::difference_type                                 C++17)
   , std::iterator_traits<Iter>::pointer
   , std::iterator_traits<Iter>::reference
   >.

.SH Member functions

   constructor     constructs a new iterator adaptor
                   \fI(public member function)\fP
   operator=       assigns another iterator
                   \fI(public member function)\fP
   base            accesses the underlying iterator
                   \fI(public member function)\fP
   operator*       accesses the pointed-to element
   operator->      \fI(public member function)\fP
   operator[]      accesses an element by index
                   \fI(public member function)\fP
   operator++
   operator++(int)
   operator+=
   operator+       advances or decrements the iterator
   operator--      \fI(public member function)\fP
   operator--(int)
   operator-=
   operator-

.SH Member objects

   Member name         Definition
   current (protected) a copy of the base() iterator

.SH Non-member functions

   make_reverse_iterator creates a std::reverse_iterator of type inferred from the
   \fI(C++14)\fP               argument
                         \fI(function template)\fP
   operator==
   operator!=
   operator<
   operator<=            compares the underlying iterators
   operator>             \fI(function template)\fP
   operator>=
   operator<=>
   (C++20)
   operator+             advances the iterator
                         \fI(function template)\fP
   operator-             computes the distance between two iterator adaptors
                         \fI(function template)\fP
   iter_move             casts the result of dereferencing the adjusted underlying
   (C++20)               iterator to its associated rvalue reference type
                         \fI(function template)\fP
   iter_swap             swap the objects pointed to by two adjusted underlying
   (C++20)               iterators
                         \fI(function template)\fP

   Helper templates

   template< class Iterator1, class Iterator2 >

       requires (!std::sized_sentinal_for<Iterator1, Iterator2>)
   inline constexpr bool disable_sized_sentinel_for<              \fI(since C++20)\fP
       std::reverse_iterator<Iterator1>,

       std::reverse_iterator<Iterator2>> = true;

   This partial specialization of std::disable_sentinel_for prevents specializations of
   reverse_iterator from satisfying sized_sentinel_for if their underlying iterators do
   not satisfy the concept.

.SH Notes

   std::reverse_iterator does not work with iterators that return a reference to a
   member object (so-called "stashing iterators"). An example of stashing iterator is
   std::filesystem::path::iterator.

.SH Example


// Run this code

 #include <iostream>
 #include <string>
 #include <iterator>

 int main()
 {
     std::string s = "Hello, world";
     std::reverse_iterator<std::string::iterator> r = s.rbegin();
     r[7] = 'O'; // replaces 'o' with 'O'
     r += 7; // iterator now points at 'O'
     std::string rev(r, s.rend());
     std::cout << rev << '\\n';
 }

.SH Output:

 OlleH

.SH See also

   iterator              base class to ease the definition of required types for simple
   (deprecated in C++17) iterators
                         \fI(class template)\fP
