.TH std::input_iterator_tag,std::output_iterator_tag,std::forward_iterator_tag, 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::input_iterator_tag,std::output_iterator_tag,std::forward_iterator_tag, \- std::input_iterator_tag,std::output_iterator_tag,std::forward_iterator_tag,

.SH Synopsis
                               std::contiguous_iterator_tag

   Defined in header <iterator>
   struct input_iterator_tag { };                                     \fB(1)\fP
   struct output_iterator_tag { };                                    \fB(2)\fP
   struct forward_iterator_tag : public input_iterator_tag { };       \fB(3)\fP
   struct bidirectional_iterator_tag : public forward_iterator_tag {  \fB(4)\fP
   };
   struct random_access_iterator_tag : public                         \fB(5)\fP
   bidirectional_iterator_tag { };
   struct contiguous_iterator_tag: public random_access_iterator_tag  \fB(6)\fP \fI(since C++20)\fP
   { };

   Defines the category of an iterator. Each tag is an empty type and corresponds to
   one of the
   five
   \fI(until C++20)\fP
   six
   \fI(since C++20)\fP iterator categories:

   1) input_iterator_tag corresponds to LegacyInputIterator.
   2) output_iterator_tag corresponds to LegacyOutputIterator.
   3) forward_iterator_tag corresponds to LegacyForwardIterator.
   4) bidirectional_iterator_tag corresponds to LegacyBidirectionalIterator.
   5) random_access_iterator_tag corresponds to LegacyRandomAccessIterator.
   6) contiguous_iterator_tag corresponds to LegacyContiguousIterator.

   Iterator category tags carry information that can be used to select the most
   efficient algorithms for the specific requirement set that is implied by the
   category.

   For every iterator type It, a typedef std::iterator_traits<It>::iterator_category is
   available, which is an alias to one of these
   five
   \fI(until C++20)\fP
   six
   \fI(since C++20)\fP tag types.

   Additionally, std::iterator_traits<It>::iterator_concept may be
   declared as an alias to one of these tags, to indicate conformance to  \fI(since C++20)\fP
   the iterator concepts (provided that the iterator also satisfies other
   requirements as declared in the concepts).

     Notes                                                \fI(since C++17)\fP
                                                          \fI(until C++20)\fP
   There is no separate tag for LegacyContiguousIterator.

.SH Example

   Common technique for algorithm selection based on iterator category tags is to use a
   dispatcher function (the alternative is std::enable_if)


// Run this code

 #include <iostream>
 #include <vector>
 #include <list>
 #include <iterator>

 // quite often implementation details are hidden in a dedicated namespace
 namespace implementation_details {
 template<class BDIter>
 void alg(BDIter, BDIter, std::bidirectional_iterator_tag)
 {
     std::cout << "alg() called for bidirectional iterator\\n";
 }

 template<class RAIter>
 void alg(RAIter, RAIter, std::random_access_iterator_tag)
 {
     std::cout << "alg() called for random-access iterator\\n";
 }
 } // namespace implementation_details

 template<class Iter>
 void alg(Iter first, Iter last)
 {
     implementation_details::alg(first, last,
         typename std::iterator_traits<Iter>::iterator_category());
 }

 int main()
 {
     std::vector<int> v;
     alg(v.begin(), v.end());

     std::list<int> l;
     alg(l.begin(), l.end());

 //    std::istreambuf_iterator<char> i1(std::cin), i2;
 //    alg(i1, i2); // compile error: no matching function for call
 }

.SH Output:

 alg() called for random-access iterator
 alg() called for bidirectional iterator

.SH See also

   iterator              base class to ease the definition of required types for simple
   (deprecated in C++17) iterators
                         \fI(class template)\fP
   iterator_traits       provides uniform interface to the properties of an iterator
                         \fI(class template)\fP
