.TH std::ranges::borrowed_range,std::ranges::enable_borrowed_range 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::borrowed_range,std::ranges::enable_borrowed_range \- std::ranges::borrowed_range,std::ranges::enable_borrowed_range

.SH Synopsis
   Defined in header <ranges>
   template<class R>

   concept borrowed_range =
       ranges::range<R> &&                                                         \fB(1)\fP

       (std::is_lvalue_reference_v<R> ||
   ranges::enable_borrowed_range<std::remove_cvref_t<R>>);
   Defined in header <ranges>
   Defined in header <span>
   Defined in header <string_view>
   template<class R>                                                               \fB(2)\fP
   inline constexpr bool enable_borrowed_range = false;

   1) The concept borrowed_range defines the requirements of a range such that a
   function can take it by value and return iterators obtained from it without danger
   of dangling.
   2) The enable_borrowed_range variable template is used to indicate whether a range
   is a borrowed_range. The primary template is defined as false.
   Specializations for all specializations of the following standard templates are
   defined as true:

     * std::basic_string_view
     * std::span
     * std::ranges::subrange
     * std::ranges::ref_view
     * std::ranges::empty_view
     * std::ranges::iota_view

   enable_borrowed_range is permitted to be specialized for cv-unqualified
   program-defined types.

   Semantic requirements

   Given an expression e such that decltype((e)) is T, T models borrowed_range only if
   the validity of iterators obtained from the object denoted by e is not tied to the
   lifetime of that object.

.SH Notes

   Users may specialize enable_borrowed_range to true for cv-unqualified
   program-defined types which model borrowed_range, and false for types which do not.
   Such specializations shall be usable in constant expressions and have type const
   bool.
