.TH std::is_layout_compatible 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::is_layout_compatible \- std::is_layout_compatible

.SH Synopsis
   Defined in header <type_traits>
   template< class T, class U >     \fI(since C++20)\fP
   struct is_layout_compatible;

   If T and U are layout-compatible types, provides the member constant value equal to
   true. Otherwise value is false.

   Every type is layout-compatible with its any cv-qualified versions, even if it is
   not an object type.

   T and U shall each be a complete type, (possibly cv-qualified) void, or an array of
   unknown bound. Otherwise, the behavior is undefined.

   If an instantiation of a template above depends, directly or indirectly, on an
   incomplete type, and that instantiation could yield a different result if that type
   were hypothetically completed, the behavior is undefined.

   The behavior of a program that adds specializations for is_layout_compatible or
   is_layout_compatible_v is undefined.

.SH Member constants

   value    true if T and U are layout-compatible, false otherwise
   \fB[static]\fP \fI(public static member constant)\fP

.SH Member functions

   operator bool converts the object to bool, returns value
                 \fI(public member function)\fP
   operator()    returns value
   \fI(C++14)\fP       \fI(public member function)\fP

.SH Member types

   Type       Definition
   value_type bool
   type       std::integral_constant<bool, value>

.SH Notes

   A signed integer type and its unsigned counterpart are not layout-compatible. char
   is layout-compatible with neither signed char nor unsigned char.

   Similar types are not layout-compatible if they are not the same type after ignoring
   top-level cv-qualification.

   An enumeration type and its underlying type are not layout-compatible.

   Array types of layout-compatible but different element types (ignoring
   cv-qualification) are not layout-compatible, even if they are of equal length.

.SH Example


// Run this code

 #include <type_traits>
 #include <iostream>

 struct Foo {
     int x;
     char y;
 };

 class Bar {
     const int u = 42;
     volatile char v = '*';
 };

 enum E0 : int {};
 enum class E1 : int {};

 int main()
 {
     std::cout << std::boolalpha
         << std::is_layout_compatible_v<const void, volatile void> << '\\n'
         << std::is_layout_compatible_v<Foo, Bar> << '\\n'
         << std::is_layout_compatible_v<Foo[2], Bar[2]> << '\\n'
         << std::is_layout_compatible_v<int, E0> << '\\n'
         << std::is_layout_compatible_v<E0, E1> << '\\n'
         << std::is_layout_compatible_v<long, unsigned long> << '\\n'
         << std::is_layout_compatible_v<char*, const char*> << '\\n'
         << std::is_layout_compatible_v<char*, char* const> << '\\n';
 }

.SH Output:

 true
 true
 false
 false
 true
 false
 false
 true

.SH See also

   is_standard_layout checks if a type is a standard-layout type
   \fI(C++11)\fP            \fI(class template)\fP
