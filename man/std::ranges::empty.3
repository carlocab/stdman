.TH std::ranges::empty 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::empty \- std::ranges::empty

.SH Synopsis
   Defined in header <ranges>
   inline namespace /*unspecified*/ {
                                                       \fI(since C++20)\fP
       inline constexpr auto empty = /*unspecified*/;  (customization point object)

   }
   Call signature
   template< class T >

       requires /* see below */

   constexpr bool empty(T&& t);

   Determines whether or not t has any elements.

   Let t be an object of type T. A call to ranges::empty is expression-equivalent to:

    1. bool(std::forward<T>(t).empty()), if that expression is valid.
    2. Otherwise, (ranges::size(std::forward<T>(t)) == 0), if that expression is valid.
    3. Otherwise, bool(ranges::begin(t) == ranges::end(t))

   In all other cases, a call to ranges::empty is ill-formed, which can result in
   substitution failure when ranges::empty(t) appears in the immediate context of a
   template instantiation.

.SH Example


// Run this code

 #include <iostream>
 #include <ranges>
 #include <vector>

 template <std::ranges::input_range R>
 void print(R&& r)
 {
     if (std::ranges::empty(r)) {
         std::cout << "\\tEmpty\\n";
         return;
     }

     std::cout << "\\tElements:";
     for (const auto& element : r) {
         std::cout << ' ' << element;
     }

     std::cout << '\\n';
 }

 int main()
 {
     {
         auto v = std::vector<int>{1, 2, 3};
         std::cout << "1. calling ranges::empty on std::vector:\\n";
         print(v);

         v.clear();
         print(v);
     }
     {
         std::cout << "2. calling ranges::empty on std::initializer_list:\\n";
         auto il = {7, 8, 9};
         print(il);

         print(std::initializer_list<int>{});
     }
     {
         std::cout << "2. calling ranges::empty on a raw array:\\n";
         int array[] = {4, 5, 6}; // array has a known bound
         print(array);
     }
     {
         struct NoEmptyNorSize : private std::vector<int> {
             auto begin() { return std::vector<int>::begin(); }
             auto end() { return std::vector<int>::end(); }
         };

         std::cout << "3. calling ranges::empty on an object that satisfies only case 3):\\n";
         print(NoEmptyNorSize{});
     }
 }

.SH Output:

 1. calling ranges::empty on std::vector:
         Elements: 1 2 3
         Empty
 2. calling ranges::empty on std::initializer_list:
         Elements: 7 8 9
         Empty
 2. calling ranges::empty on a raw array:
         Elements: 4 5 6
 3. calling ranges::empty on an object that satisfies only case 3):
         Empty

.SH See also

   empty   checks whether the container is empty
   \fI(C++17)\fP \fI(function template)\fP
