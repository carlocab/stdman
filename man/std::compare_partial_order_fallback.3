.TH std::compare_partial_order_fallback 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::compare_partial_order_fallback \- std::compare_partial_order_fallback

.SH Synopsis
   Defined in header <compare>
   inline namespace /* unspecified */ {

       inline constexpr /* unspecified */                                 \fI(since C++20)\fP
           compare_partial_order_fallback = /* unspecified */;

   }
   Call signature
   template< class T, class U >

       requires /* see below */
   constexpr std::partial_ordering

       compare_partial_order_fallback(T&& t, U&& u) noexcept(/* see
   below */);

   Performs three-way comparison on t an u and produces a result of type
   std::partial_ordering, even if the operator <=> is unavailable.

   Let t and u be expressions and T and U denote decltype((t)) and decltype((u))
   respectively, std::compare_partial_order_fallback(t, u) is expression-equivalent to:

     * If std::is_same_v<std::decay_t<T>, std::decay_t<U>> == true:

          * the expression is expression-equivalent to std::partial_order(t, u), if it
            is a well-formed expression;
          * Otherwise, if t == u and t < u are both well-formed and convertible to
            bool, the expression is expression-equivalent to

 t == u ? std::partial_ordering::equivalent :
 t < u  ? std::partial_ordering::less :
 u < t  ? std::partial_ordering::greater :
          std::partial_ordering::unordered

   except that t and u are evaluated only once.

     * In all other cases, std::compare_partial_order_fallback(t, u) is ill-formed.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   partial_order performs 3-way comparison and produces a result of type
   (C++20)       std::partial_ordering
                 (customization point object)

.SH Category:

     * Todo no example
