.TH std::basic_string::operator= 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::basic_string::operator= \- std::basic_string::operator=

.SH Synopsis
   basic_string& operator=(              (until
   const basic_string& str );            C++20)
   constexpr basic_string&               (since
   operator=( const                      C++20)
   basic_string& str );
                                                 (since
   basic_string& operator=(                      C++11)
   basic_string&& str );                         (until
                                                 C++17)
   basic_string& operator=(                      (since
   basic_string&& str )                          C++17)
   noexcept(/* see below */);                    (until
                                                 C++20)
   constexpr basic_string&
       operator=( basic_string&&                 (since
   str ) noexcept(/* see below                   C++20)
   */);
   basic_string& operator=(                              (until
   const CharT* s );                                     C++20)
   constexpr basic_string&       \fB(1)\fP                     (since
   operator=( const CharT* s );                          C++20)
   basic_string& operator=(                                      (until
   CharT ch );                       \fB(2)\fP                         C++20)
   constexpr basic_string&                                       (since
   operator=( CharT ch );                                        C++20)
   basic_string& operator=(                                              (since
   std::initializer_list<CharT>                                          C++11)
   ilist );                                                              (until
                                         \fB(3)\fP                             C++20)
   constexpr basic_string&
   operator=(                                    \fB(4)\fP                     (since
   std::initializer_list<CharT>                                          C++20)
   ilist );                                              \fB(5)\fP
   template<class T>                                                             (since
   basic_string& operator=(                                                      C++17)
   const T& t );                                                                 (until
                                                                 \fB(6)\fP             C++20)
   template<class T>                                                             (since
   constexpr basic_string&                                                       C++20)
   operator=( const T& t );

   Replaces the contents of the string.

   1) Replaces the contents with a copy of str. If *this and str are the same object,
   this function has no effect.
   2) Replaces the contents with those of str using move semantics. str is in a valid
   but unspecified state afterwards. If
   std::allocator_traits<Allocator>::propagate_on_container_move_assignment() is true,
   the target allocator is replaced by a copy of the source allocator. If it is false
   and the source and the target allocators do not compare equal, the target cannot
   take ownership of the source memory and must assign each character individually,
   allocating additional memory using its own allocator as needed. Unlike other
   container move assignments, references, pointers, and iterators to str may be
   invalidated.
   3) Replaces the contents with those of null-terminated character string pointed to
   by s as if by assign(s, Traits::length(s)).
   4) Replaces the contents with character ch as if by assign(std::addressof(ch), 1)
   5) Replaces the contents with those of the initializer list ilist as if by
   assign(ilist.begin(), ilist.size())
   6) Implicitly converts t to a string view sv as if by std::basic_string_view<CharT,
   Traits> sv = t;, then replaces the contents with those of the sv as if by
   assign(sv). This overload only participates in overload resolution if
   std::is_convertible_v<const T&, std::basic_string_view<CharT, Traits>> is true and
   std::is_convertible_v<const T&, const CharT*> is false.

.SH Parameters

   ch    - value to initialize characters of the string with
   str   - string to be used as source to initialize the string with
   s     - pointer to a null-terminated character string to use as source to initialize
           the string with
   ilist - std::initializer_list to initialize the string with
   t     - object convertible to std::basic_string_view to initialize the string with

.SH Return value

   *this

.SH Complexity

   1) linear in size of str
   2) linear in the size of this (formally, each CharT has to be destroyed). If
   allocators do not compare equal and do not propagate, then also linear in the size
   of str (copy must be made)
   3) linear in size of s
   4) constant.
   5) linear in size of ilist

.SH Exceptions

2)
noexcept specification:                                                                  (since
noexcept(std::allocator_traits<Allocator>::propagate_on_container_move_assignment::value C++17)
 || std::allocator_traits<Allocator>::is_always_equal::value)

   If the operation would result in size() > max_size(), throws std::length_error.

   If an exception is thrown for any reason, this function has no effect  \fI(since C++11)\fP
   \fI(strong exception guarantee)\fP.

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to           Behavior as published              Correct behavior
   LWG 2063 C++11      non-normative note stated that swap is a  corrected to support
                       valid implementation of move assignment   allocators
   LWG 2946 C++17      string_view overload causes ambiguity in  avoided by making it a
                       some cases                                template

.SH Example


// Run this code

 #include <string>
 #include <iostream>
 #include <iomanip>

 int main()
 {
     std::string str1;
     std::string str2 { "alpha" };

     // (1) operator=( const basic_string& );
     str1 = str2;
     std::cout << std::quoted(str1) << ' ' // "alpha"
               << std::quoted(str2) << '\\n'; // "alpha"

     // (2) operator=( basic_string&& );
     str1 = std::move(str2);
     std::cout << std::quoted(str1) << ' ' // "alpha"
               << std::quoted(str2) << '\\n'; // "" or "alpha" (unspecified)

     // (3) operator=( const CharT* );
     str1 = "beta";
     std::cout << std::quoted(str1) << '\\n'; // "beta"

     // (4) operator=( CharT );
     str1 = '!';
     std::cout << std::quoted(str1) << '\\n'; // "!"

     // (5) operator=( std::initializer_list<CharT> );
     str1 = {'g','a','m','m','a'};
     std::cout << std::quoted(str1) << '\\n'; // "gamma"

     // (6) operator=( const T& );
     str1 = 35U; // equivalent to str1 = static_cast<char>(35U);
     std::cout << std::quoted(str1) << '\\n'; // "#" (ASCII = 35)
 }

.SH Possible output:

 "alpha" "alpha"
 "alpha" ""
 "beta"
 "!"
 "gamma"
 "#"

.SH See also

   constructor   constructs a basic_string
                 \fI(public member function)\fP
   assign        assign characters to a string
                 \fI(public member function)\fP

.SH Category:

     * conditionally noexcept
