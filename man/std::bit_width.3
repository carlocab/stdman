.TH std::bit_width 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::bit_width \- std::bit_width

.SH Synopsis
   Defined in header <bit>
   template< class T >                   \fI(since C++20)\fP
   constexpr T bit_width(T x) noexcept;

   If x is not zero, calculates the number of bits needed to store the value x, that
   is, \\(1 + \\lfloor log_2(x) \\rfloor\\)1 + floor(log
   2(x)). If x is zero, returns zero.

   This overload only participates in overload resolution if T is an unsigned integer
   type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned
   long long, or an extended unsigned integer type).

.SH Return value

   Zero if x is zero; otherwise, one plus the base-2 logarithm of x, with any
   fractional part discarded.

.SH Notes

   This function is equivalent to return std::numeric_limits<T>::digits -
   std::countl_zero(x);.

.SH Example


// Run this code

 #include <bit>
 #include <bitset>
 #include <iostream>

 auto main() -> int
 {
     for (unsigned x{0}; x != 8; ++x)
     {
         std::cout
             << "bit_width( "
             << std::bitset<4>{x} << " ) = "
             << std::bit_width(x) << '\\n';
     }
 }

.SH Output:

 bit_width( 0000 ) = 0
 bit_width( 0001 ) = 1
 bit_width( 0010 ) = 2
 bit_width( 0011 ) = 2
 bit_width( 0100 ) = 3
 bit_width( 0101 ) = 3
 bit_width( 0110 ) = 3
 bit_width( 0111 ) = 3

.SH See also

   countl_zero counts the number of consecutive 0 bits, starting from the most
   (C++20)     significant bit
               \fI(function template)\fP
