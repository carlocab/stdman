.TH std::ranges::views::empty,std::ranges::empty_view 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::views::empty,std::ranges::empty_view \- std::ranges::views::empty,std::ranges::empty_view

.SH Synopsis
   template<class T>

       requires std::is_object_v<T>                                \fB(1)\fP \fI(since C++20)\fP

   class empty_view : public ranges::view_interface<empty_view<T>>
   namespace views {

       template<class T> inline constexpr empty_view<T> empty{};   \fB(2)\fP \fI(since C++20)\fP

   }

   1) A range adaptor that produces a view of no elements of a particular type.
   2) Variable template for empty_view.

.SH Member functions

std::ranges::empty_view::begin

   static constexpr T* begin() noexcept { return nullptr; }

   empty_view does not reference any element.

std::ranges::empty_view::end

   static constexpr T* end() noexcept { return nullptr; }

   empty_view does not reference any element.

std::ranges::empty_view::data

   static constexpr T* data() noexcept { return nullptr; }

   empty_view does not reference any element.

std::ranges::empty_view::size

   static constexpr std::size_t size() noexcept { return 0; }

   empty_view is always empty.

std::ranges::empty_view::empty

   static constexpr bool empty() noexcept { return true; }

   empty_view is always empty.

.SH Example


// Run this code

 #include <ranges>

 int main()
 {
     std::ranges::empty_view<int> e;
     static_assert(std::ranges::empty(e));
     static_assert(0 == e.size());
 }
