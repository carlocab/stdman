.TH std::ranges::size 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::size \- std::ranges::size

.SH Synopsis
   Defined in header <ranges>
   inline namespace /*unspecified*/ {
                                                      \fI(since C++20)\fP
       inline constexpr auto size = /*unspecified*/;  (customization point object)

   }
   Call signature
   template< class T >

       requires /* see below */

   constexpr auto size(T&& t);

   Calculates the number of elements in t in constant time.

   Let t be an object of type T. A call to ranges::size is expression-equivalent to:

    1. std::extent_v<T>, if T is an array type with a known bound.
    2. Otherwise, std::forward<T>(t).size(), if not
       ranges::disable_sized_range<std::remove_cv_t<T>>, and std::forward<T>(t).size()
       is valid and returns a type that is /*integer-like*/.

       where /*integer-like*/ is a type that models std::integral or is a class that
       behaves like an integer type, including all operators, implicit conversions, and
       std::numeric_limits specializations.
    3. Otherwise, size(std::forward<T>(t)), if not
       ranges::disable_sized_range<std::remove_cv_t<T>>, and size(std::forward<T>(t))
       is valid and returns a type that is /*integer-like*/, where the overload
       resolution is performed with the following candidates:

          * void begin(auto&) = delete;
          * void begin(const auto&) = delete;

    4. Otherwise, /*to-unsigned-like*/(ranges::end(t) - ranges::begin(t)), if T models
       ranges::forward_range and ranges::sentinel_t<T> models
       std::sized_sentinel_for<ranges::iterator_t<T>>.

       where /*to-unsigned-like*/ denotes an explicit conversion to an /*integer-like*/
       type that behaves like an unsigned integer type, including all operators,
       implicit conversions, and std::numeric_limits specializations.

   In all other cases, a call to ranges::size is ill-formed, which can result in
   substitution failure when ranges::size(t) appears in the immediate context of a
   template instantiation.

.SH Example


// Run this code

 #include <iostream>
 #include <ranges>
 #include <type_traits>
 #include <vector>

 int main()
 {
     auto v = std::vector<int>{};
     std::cout << "ranges::size(v) == " << std::ranges::size(v) << '\\n';

     auto il = {7};
     std::cout << "ranges::size(il) == " << std::ranges::size(il) << '\\n';

     int array[] = {4, 5}; // array has a known bound
     std::cout << "ranges::size(array) == " << std::ranges::size(array) << '\\n';

     std::cout << std::boolalpha << "is_signed: "
               << std::is_signed_v<decltype(std::ranges::size(v))> << '\\n';
 }

.SH Output:

 ranges::size(v) == 0
 ranges::size(il) == 1
 ranges::size(array) == 2
 is_signed: false

.SH See also

   ranges::ssize obtains the size of a range whose size can be calculated in constant
   (C++20)       time and converts it to signed integral
                 (customization point object)
   size
   ssize         returns the size of a container or array
   \fI(C++17)\fP       \fI(function template)\fP
   (C++20)
