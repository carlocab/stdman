.TH std::basic_string_view::basic_string_view 3 "2021.11.17" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::basic_string_view::basic_string_view \- std::basic_string_view::basic_string_view

.SH Synopsis
   constexpr basic_string_view() noexcept;                            \fB(1)\fP \fI(since C++17)\fP
   constexpr basic_string_view(const basic_string_view& other)        \fB(2)\fP \fI(since C++17)\fP
   noexcept = default;
   constexpr basic_string_view(const CharT* s, size_type count);      \fB(3)\fP \fI(since C++17)\fP
   constexpr basic_string_view(const CharT* s);                       \fB(4)\fP \fI(since C++17)\fP
   template<class It, class End>                                      \fB(5)\fP \fI(since C++20)\fP
   constexpr basic_string_view(It first, End last);

   1) Default constructor. Constructs an empty basic_string_view. After construction,
   data() is equal to nullptr, and size() is equal to 0.
   2) Copy constructor. Constructs a view of the same content as other. After
   construction, data() is equal to other.data(), and size() is equal to other.size().
   3) Constructs a view of the first count characters of the character array starting
   with the element pointed by s. s can contain null characters. The behavior is
   undefined if [s, s+count) is not a valid range (even though the constructor may not
   access any of the elements of this range). After construction, data() is equal to s,
   and size() is equal to count.
   4) Constructs a view of the null-terminated character string pointed to by s, not
   including the terminating null character. The length of the view is determined as if
   by Traits::length(s). The behavior is undefined if [s, s+Traits::length(s)) is not a
   valid range. After construction, data() is equal to s, and size() is equal to
   Traits::length(s).
   5) Constructs a basic_string_view over the range [first, last). The behavior is
   undefined if [first, last) is not a valid range, if It does not actually model
   contiguous_iterator, or if End does not actually model sized_sentinel_for for It.
   After construction, data() is equal to std::to_address(first), and size() is equal
   to last - first.

   This overload only participates in overload resolution if

     * It satisfies contiguous_iterator,
     * End satisfies sized_sentinel_for for It,
     * std::iter_value_t<It> and CharT are the same type, and
     * End is not convertible to std::size_t.

.SH Parameters

   other - another view to initialize the view with
   s     - pointer to a character array or a C string to initialize the view with
   count - number of characters to include in the view
   first - iterator to the first character of the sequence
   last  - iterator past the last character of the sequence or another sentinel

.SH Complexity

   1-3,5) constant
   4) linear in length of s

.SH Example


// Run this code

 #include <array>
 #include <iostream>
 #include <string>
 #include <string_view>
 int main()
 {
     std::wstring_view wcstr_v = L"xyzzy";

     char array[3] = {'B', 'a', 'r'};
     std::string_view array_v(array, std::size(array));

     std::string cppstr = "Foo";
     std::string_view cppstr_v(cppstr);

     std::array ar = {'P', 'u', 'b'};
     std::string_view ar_v(ar.begin(), ar.end()); // C++20

     std::cout << cppstr_v << ' '
               << array_v << ' '
               << ar_v << ' '
               << wcstr_v.size() << '\\n';
 }

.SH Output:

 Foo Bar Pub 5

.SH See also

   operator= assigns a view
             \fI(public member function)\fP
